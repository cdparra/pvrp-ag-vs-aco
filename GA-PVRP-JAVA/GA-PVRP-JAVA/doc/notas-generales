NOTAS VARIAS DE DOCUMENTACIÓN SOBRE EL MODELADO DE LA SOLUCIÓN DE PVRP PARA AGS
===============================================================================

1. En primer lugar hay que decir que tenemos un problema multinivel: 
   - 1 Problema de planificación --> de que manera visitar a los clientes
   - 1 Problema de ruteo ----------> encontrar rutas óptimas para cada día y 
                                     vehículo disponible. 

2. La estrategia común para resolver los problemas multinivel es aplicar un 
   algoritmo adecuado en cada nivel, y luego tratar las soluciones de ambos
   niveles como dos objetivos a optimizar, sin embargo en este trabajo nos planteamos
   el desafío de resolver el problema solo con un algoritmo y una representación
   única. 


NOTAS SOBRE EL PROBLEMA
===============================================================================

El problema es generar el conjunto de rutas de menor costos para M camiones que
tienen que visitar a n clientes, cada uno de los cuales requiere una frecuencia
de visita en k días, y tiene una demanda que satisfacer.

M = camiones
k = dias
n = clientes


NOTAS SOBRE SOLUCIONES
===============================================================================

1. REPRESENTACIÓN DE SOLUCIÓN:

   *Alelo ------> Ruta de un camión para un día. 
                 Vector de enteros, cada entero un cliente. 

   *Gen --------> Conjunto de rutas de un camion en el periodo de k días
                 Vector de alelos

   Cromosoma --> Conjunto de rutas de k días para cada camión
                 Vector de genes.

*Conceptos a revisar: 
  - ¿Si definimos así, podemos igual cruzar y mutar a nivel de celdas de la 
     matriz tridimensional?
  - Hay que revisar si el gen no es directamente el entero en cada celda y 
    el alelo un entero de 1 a N (que representa el número de cliente)

En síntesis, decidimos usar una matriz tridimensional que contiene en cada celda
el entero que representa a un cliente. La Matríz se podría definir así.

     M = { Aijk | i pertenece a dias, 
                  j pertenece a camiones,  
                  k pertenece a clientes }

     dias = { X | X = 1,2,3,...,k }
     camiones = { X | X = 1,2,3,...,m }
     clientes = { X | X = 1,2,3,...,n }


Una ruta es una sucesión de nodos. Por simplificación, nuestro representación
no incluye el nodo 0 (deposito). Se asume que todas las rutas empiezan y terminan 
en 0 y se tiene en cuenta esta observación al calcular el fitness.

RESTRICCIONES
 - Cada cliente requiere una cantidad de visitas a ser satisfacha.
   Para cada ci, rci = X tal que X =< k (cantidad de días)
 - Cada alelo es una ruta que corresponde a un día, y en la cual un cliente 
   solo debe ser visitado una vez en el día (una ruta no debe repetir nodos)
 - Un camión podría no retornar en el mismo día al depósito, pero nosotros optamos
   para simplificar la solución y la representación TODOS LOS CAMIONES SALEN Y 
   VUELVEN EN EL MISMO DÍA AL DEPÓSITO. 

***PROBLEMAS DE LA GENERACIÓN DE NUESTRA POBLACIÓN
 - Inicialmente, teníamos en cuenta la capacidad de los camiones, pero esto 
   nos complicaba enormente debido a que constantemente se producía un cromosoma
   que no visitaba a todos los nodos para satisfacer la restricción de carga de 
   los camiones. 
 - Resolver este problema implicaba muchas cosas que al final decidimos obviar, 
   ya que la literatura general no define como restriccción de PVRP la capacidad
   de los camiones. 
   OBS: como optimización, para producir mejores individuos, se podría tener en
        cuenta un esquema híbrido en el cual al iniciar la población tenemos 
        cuenta la capacidad de los camiones, y si al final quedan clientes por
        visitar, asignarlos aleatoriamente a distintos camiones
   
2. GENERACIÓN DE LA POBLACIÓN INICIAL

Generamos una población de 30 individuos factibles en el sentido que todos 
cumplen con la restrición de que la cantidad de visitas recibidas por un cliente
es igual a la cantidad de visitas que requiere. 

2. SELECCIÓN


Los m´etodos de selección proporcional requieren de dos pasos a través de toda 
la población en cada generación:

1. Calcular la aptitud media (y, si se usa escalamiento sigma, la desviación
   estándar).

2. Calcular el valor esperado de cada individuo.

El uso de jerarquías requiere que se ordene toda la población (una operación
cuyo costo puede volverse significativo en poblaciones grandes).
La selección mediante torneo es similar a la de jerarquías en términos de la
presión de selección, pero es computacionalmente más adecuada para implementarse
en paralelo.

Debido a la naturaleza compleja de nuestros cromosomas (que tiene 3 niveles de 
abstracción) consideramos más adecuado utilizar una estrategia de torneo. 

Por otro lado, no se consideraron las estrategias de selección de estado Uniforme, 
ya que estas (propuesta por Whitley [228])  se usan en AGs no generacionales,
en los cuales sólo unos cuantos individuos son reemplazados en cada generación
(los menos aptos).

Esta técnica suele usarse cuando se evolucionan sistemas basados en reglas
(p.ej., sistemas clasificadores) en los que el aprendizaje es incremental.

Nuestro caso no cuadra en esta definición ya que es muy generacional. 

-------
TODO



3. CRUCE

El cruce es la parte que más nos complicó inicialmente en el trabajo. 
___________________________________________________________________
|[2,3,1,4,5,2] [5,23,3,1,5,6,5,7] ..... *
|. ...
|: ...

(los datos son los mismos, pero es para tener una idea nomas)___________________________________________________________________
|[2,3,1,4,5,2] [5,23,3,1,5,6,5,7] .....
|. ... **
|: ...


* se cruza con ** a nivel de cada ruta. La idea básica del cruce es mantener la 
  primera mitad de las dos rutas, y la segunda mitad construir con los nodos
  de la ruta complementaria que no se encuentran en la actual. 
  
  Ri -> [10,3,1,4,5,2] 
  Rj -> [4,23,3,1,5,6,9,7]

El procedimiento es así:

1. Se elige punto de corte para cada ruta: 

  [10,3,1     |  4,5,2]   
  [4,23,3,1  |  5,6,9,7]

2. Se preprocesan las rutas para establecer el criterio de validez del alelo:
   - El criterio de validez del alelo es que no se modifique la cantidad de 
     visitas realizadas en las rutas originales a cada cliente que existe 
     en las mismas.

   Para ello, armamos una lista de 1..N donde marcamos la cantidad de visitas de 
   cada nodo entre las dos rutas (máximo será dos). 

   Se debe mantener la lista de visitas requeridas por cada cliente de manera 
   global durante el proceso y asegurarse de que todos sean visitados lo que 
   requieren.

   Solo tenemos que asegurar que si vuelven a aparecer en las 2das. mitades se los 
   cuente adecuadamente.

  [10,3,1   |  4,5,2]   
  [4,23,3,1  |  5,6,9,7]
   
---------------------------------------------
V -> [ 0, 1 , 0 , 1 , 2 , 1 , 1 , 0 , 1 , ...]
       1  2   3   4   5   6   7   8   9   ...

3. Copiamos las dos primeras mitades. 

R1 ->  [10,3,1    |  4,5,2  ]   
R2 ->  [4,23,3,1  |  5,6,9,7]
---------------------------------------------
H1 ->  [10,3,1     |         ]
       --<R1/1>--
H2 ->  [4,23,3,1  |         ]
       --<R2/1>--

* Denotamos Ri/1 como la primera mitad de Ri. 

4. Completamos las dos segundas mitades de la siguiente manera. 
   - Recorremos Ri desde el inicio y en cada caso, colocamos el valor del 
     cliente ci en Hi+1 si y solo si cumple con las siguientes condiciones, que
     definen el criterio de validez de un alelo. 
     * ci no pertenece a Ri+1/1
     * V[i] > 0. 

     Se insertan tantos clientes como la cantidad de los mismos en la segunda mitad 
     de Ri+1

   - Si se cumplen las condiciones y se ingresa al cliente a la ruta Hi+1, se 
     actualiza V de la siguiente manera: 
     * V[i]--;

   En nuestro ejemplo: 

R1 ->  [10,3,1,4,   |  5,2,8  ]   corte1=4,c1Size-corte1=3
R2 ->  [4,23,3,1,2  |  5,6,9,7]   corte2=5,c2Size-corte2=4
---------------------------------------------
H1 ->  [10,3,1,4    | 2,5,6,9]   corte1=4,c1Size-corte2=4    7
       --<R1/1>--
H2 ->  [4,23,3,1,2  |5,8 ]   corte2=5,c2Size-corte1=3
       --<R2/1>--        

Para cada cliente con V[i]>0 hacer
     l <- V[i]
     Si l==2
         metener i en las dos rutas.
     sino si l==1
         -- Ver donde sobra espacio
         espacio1 = (corte1 +c1Size-corte2) - H1.size();
         espacio2 = (corte2 +c2Size-corte1) - H2.size();

         si espacio1>0 entonces meter l en H1
         sino entonces meter l en H2. 
     fin

                    V -> [ 0, 1 , 0 , 1 , 2 , 1 , 1 , 0 , 1 , 0...]
                           1  2   3   4   5   6   7   8   9  10...
Paso 1:                  [ 0, 1 , 0 , 0 , 2 , 1 , 1 , 0 , 1 , ...]
Paso 2, 3, 4: Descartado [ 0, 1 , 0 , 0 , 2 , 1 , 1 , 0 , 1 , ...]
Paso 5:                  [ 0, 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , ...]
Paso 6:                  [ 0, 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , ...]
Paso 7:                  [ 0, 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , ...] 
----> Obs. Especial
  La lista de clientes 
  de la ruta recorrida
  que no fueron incluidos
  en la nueva ruta, se 
  deben almacenar porque 
  se incluirán en el otro
  hijo. En este caso, se
  guarda "7"
Pasamos a H2
Paso 8:                  [ 0, 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , ...]
Paso 9:                  [ 0, 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , ...]
--> A partir de aqui 
    colocamos los que 
    faltaron en el 
    recorrido de la 
    ruta anterior. 
Paso 10:                  [ 0, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , ...]

----------------------------------------------------------------------------
HIJOS PRODUCIDOS

H1 ->  [10,3,1,4,5,6,9]
H2 ->  [4,23,3,1,5,2,7]



Al terminar, se repite el mismo proceso con los demás padres.

En cada caso, se cruza el camión i del cromosoma 1 con el camión (i+1) mod k del
otro camión. Esto es para asegurar que los cromosomas no se produzcan todos con 
cargas excesivas a los primeros camiones. 


4. MUTACIÓN
   La primera idea es aplicar el cruce, pero sobre el mismo Cromosoma. Esto no
   es tan bueno. 

   Segunda idea: random del porcentaje de mutación. Según este porcentaje, 
   recorremos el cromosoma y usando el porcentaje cambiamos o no el valor.
   - Primero, reinicializamos vector de visitas requeridas
   - A medida que recorremos, segun aparecen los clientes disminuimos sus 
     visitas requeridas y si se decide cambiar al cliente, se disminuye al que 
     entra y se aumenta al que sale
   - La probabilidad de mutación mencionada en este apartado no es la misma que 
     la probabilidad de mutacion del Cromosoma en sí.


ALGORITMO SIMPLE
==============================================================================

inicializarPop
evaluacion 
seleccion
reemplazo
cruce
mutacion
evaluar


