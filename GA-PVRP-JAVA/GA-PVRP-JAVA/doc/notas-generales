NOTAS VARIAS DE DOCUMENTACIÓN SOBRE EL MODELADO DE LA SOLUCIÓN DE PVRP PARA AGS
===============================================================================

1. En primer lugar hay que decir que tenemos un problema multinivel: 
   - 1 Problema de planificación --> de que manera visitar a los clientes
   - 1 Problema de ruteo ----------> encontrar rutas óptimas para cada día y 
                                     vehículo disponible. 

2. La estrategia común para resolver los problemas multinivel es aplicar un 
   algoritmo adecuado en cada nivel, y luego tratar las soluciones de ambos
   niveles como dos objetivos a optimizar, sin embargo en este trabajo nos planteamos
   el desafío de resolver el problema solo con un algoritmo y una representación
   única. 


NOTAS SOBRE EL PROBLEMA
===============================================================================

El problema es generar el conjunto de rutas de menor costos para M camiones que
tienen que visitar a n clientes, cada uno de los cuales requiere una frecuencia
de visita en k días, y tiene una demanda que satisfacer.

M = camiones
k = dias
n = clientes


NOTAS SOBRE SOLUCIONES
===============================================================================

1. REPRESENTACIÓN DE SOLUCIÓN:

   *Alelo ------> Ruta de un camión para un día. 
                 Vector de enteros, cada entero un cliente. 

   *Gen --------> Conjunto de rutas de un camion en el periodo de k días
                 Vector de alelos

   Cromosoma --> Conjunto de rutas de k días para cada camión
                 Vector de genes.

*Conceptos a revisar: 
  - ¿Si definimos así, podemos igual cruzar y mutar a nivel de celdas de la 
     matriz tridimensional?
  - Hay que revisar si el gen no es directamente el entero en cada celda y 
    el alelo un entero de 1 a N (que representa el número de cliente)

En síntesis, decidimos usar una matriz tridimensional que contiene en cada celda
el entero que representa a un cliente. La Matríz se podría definir así.

     M = { Aijk | i pertenece a dias, 
                  j pertenece a camiones,  
                  k pertenece a clientes }

     dias = { X | X = 1,2,3,...,k }
     camiones = { X | X = 1,2,3,...,m }
     clientes = { X | X = 1,2,3,...,n }


Una ruta es una sucesión de nodos. Por simplificación, nuestro representación
no incluye el nodo 0 (deposito). Se asume que todas las rutas empiezan y terminan 
en 0 y se tiene en cuenta esta observación al calcular el fitness.

RESTRICCIONES
 - Cada cliente requiere una cantidad de visitas a ser satisfacha.
   Para cada ci, rci = X tal que X =< k (cantidad de días)
 - Cada alelo es una ruta que corresponde a un día, y en la cual un cliente 
   solo debe ser visitado una vez en el día (una ruta no debe repetir nodos)
 - Un camión podría no retornar en el mismo día al depósito, pero nosotros optamos
   para simplificar la solución y la representación TODOS LOS CAMIONES SALEN Y 
   VUELVEN EN EL MISMO DÍA AL DEPÓSITO. 

***PROBLEMAS DE LA GENERACIÓN DE NUESTRA POBLACIÓN
 - Inicialmente, teníamos en cuenta la capacidad de los camiones, pero esto 
   nos complicaba enormente debido a que constantemente se producía un cromosoma
   que no visitaba a todos los nodos para satisfacer la restricción de carga de 
   los camiones. 
 - Resolver este problema implicaba muchas cosas que al final decidimos obviar, 
   ya que la literatura general no define como restriccción de PVRP la capacidad
   de los camiones. 
   OBS: como optimización, para producir mejores individuos, se podría tener en
        cuenta un esquema híbrido en el cual al iniciar la población tenemos 
        cuenta la capacidad de los camiones, y si al final quedan clientes por
        visitar, asignarlos aleatoriamente a distintos camiones
   
2. GENERACIÓN DE LA POBLACIÓN INICIAL

Generamos una población de 30 individuos factibles en el sentido que todos 
cumplen con la restrición de que la cantidad de visitas recibidas por un cliente
es igual a la cantidad de visitas que requiere. 

2. SELECCIÓN


Los m´etodos de selección proporcional requieren de dos pasos a través de toda 
la población en cada generación:

1. Calcular la aptitud media (y, si se usa escalamiento sigma, la desviación
   estándar).

2. Calcular el valor esperado de cada individuo.

El uso de jerarquías requiere que se ordene toda la población (una operación
cuyo costo puede volverse significativo en poblaciones grandes).
La selección mediante torneo es similar a la de jerarquías en términos de la
presión de selección, pero es computacionalmente más adecuada para implementarse
en paralelo.

Debido a la naturaleza compleja de nuestros cromosomas (que tiene 3 niveles de 
abstracción) consideramos más adecuado utilizar una estrategia de torneo. 

Por otro lado, no se consideraron las estrategias de selección de estado Uniforme, 
ya que estas (propuesta por Whitley [228])  se usan en AGs no generacionales,
en los cuales sólo unos cuantos individuos son reemplazados en cada generación
(los menos aptos).

Esta técnica suele usarse cuando se evolucionan sistemas basados en reglas
(p.ej., sistemas clasificadores) en los que el aprendizaje es incremental.

Nuestro caso no cuadra en esta definición ya que es muy generacional. 

-------
TODO



3. CRUCE

El cruce es la parte que más nos complicó inicialmente en el trabajo. 
___________________________________________________________________
|[2,3,1,4,5,2] [5,23,3,1,5,6,5,7] ..... *
|. ...
|: ...

(los datos son los mismos, pero es para tener una idea nomas)___________________________________________________________________
|[2,3,1,4,5,2] [5,23,3,1,5,6,5,7] .....
|. ... **
|: ...


* se cruza con ** a nivel de cada ruta. La idea básica del cruce es mantener la 
  primera mitad de las dos rutas, y la segunda mitad construir con los nodos
  de la ruta complementaria que no se encuentran en la actual. 
  
R1 ->  [10,3,1,4,5,2,8  ]   
R2 ->  [4,23,3,1,2,5,6,9,7]   

El procedimiento es así:

1. Se elige punto de corte para cada ruta: 

R1 ->  [10,3,1,4,   |  5,2,8  ]   
R2 ->  [4,23,3,1,2  |  5,6,9,7]   

2. Se preprocesan las rutas para establecer el criterio de validez del alelo:
   - El criterio de validez es que los requerimientos de visitas de cada cliente
     se cumplan con las rutas generadas. Esto es, la ruta no puede albergar 
     clientes que ya se visitaron la cantidad de veces requeridas. 
   - Además, se debe asegurar que a un cliente no se le visite dos veces en la
     misma ruta.

   Para asegurar esta validez, tenemos dos informaciones que mantenemos. Una 
   información global y una información local. 

   *Información Global
   ----------------------------------
   Se trata de la lista de requerimientos de visita de cada cliente que se 
   por cada Cromosoma nuevo generado. Cada vez que algún cliente 
   se incluye en alguna ruta del cromosoma correspondiente, se disminuyen sus
   requerimientos.

   Se implementa por medio de vector de enteros de tantas posiciones como 
   clientes. Cada elemento i del vector contiene el requerimiento del cliente i

   Ejemplo: Reqs = [4, 5 , 2 , .... 8 ]

   *Información Local 
   ------------------------------------
   Con la información global, ya bastaría para asegurar el requerimiento de 
   visitas. Es decir, realizar el cruce sin más validación que el control de la
   información global, pero al final de las iteraciones del cruce necesitaríamos
   un ajuste para incluir a clientes que eventualmente fueron deshechados en el 
   camino por no cumplir con los requerimientos de uno de los hijos.

   Optamos por una optimización local al algoritmo de cruce que consiste en
   mantener otra lista local de la cantidad de visitas realizadas a un cliente 
   entre las dos  rutas a cruzar (como máximo sería dos, o sea, 
   una vez en cada ruta). 

   Nos aseguramos de que localmente no se visite de más ni de menos de lo que 
   se visita entre las dos rutas a cruzar. De esta manera, nunca quedarían al 
   final del cruce clientes que recolocar debido a que localmente se resuelven 
   las visitas requeridas por cada par de rutas. Además, de esta manera se 
   asegura una cierta semejanza entre padres e hijos ya que cada ruta incluye 
   a todos los clientes que de alguna manera se incluían originalmente en los
   dos padres y no se pierde ninguno ni se mueve a otras rutas de otros camiones.

   Para ello, armamos una lista de 1..N donde marcamos la cantidad de visitas de 
   cada nodo entre las dos rutas (máximo será dos). 

   Del mismo modo que el vector global, la información que contiene este vector 
   es una cantidad requerida de visitas por cada cliente a nivel local. 
  
   Inicializamos el vector a la cantidad de visitas que recibió cada cliente 
   sumando las visitas entre las dos rutas a cruzarse (máximo será 2). A medida
   que un cliente ingresa en una nueva ruta de un hijo, se disminuye el valor 
   de esta entrada para indicar las veces que le restan por visitar. 

R1 ->  [10,3,1,4,   |  5,2,8  ]   
R2 ->  [4,23,3,1,2  |  5,6,9,7]   
   
---------------------------------------------
V -> [ 2, 2 , 2 , 2 , 2 , 1 , 1 , 1 , 1 , 1 ...  1 ]
       1  2   3   4   5   6   7   8   9  10 ... 23

3. Copiamos las dos primeras mitades, verificando por cada cliente i que
   V[i] y Reqs[i] sean mayores que cero. Si se cumple la condición, incluimos
   los clientes en la primera mitad de los hijos generados, H1 y H2. 
   - Al incluir los clientes se hace V[i]-- y Reqs[i]--.

R1 ->  [10,3,1    |  4,5,2  ]   
R2 ->  [4,23,3,1  |  5,6,9,7]
---------------------------------------------
H1 ->  [10,3,1     |         ]
       --<R1/1>--
H2 ->  [4,23,3,1  |         ]
       --<R2/1>--

* Denotamos Ri/1 como la primera mitad de Ri. 

4. Completamos las dos segundas mitades de la siguiente manera. 
   - Recorremos Ri desde el inicio y en cada caso, colocamos el valor del 
     cliente ci en Hi+1 si y solo si cumple con las siguientes condiciones, que
     definen el criterio de validez de un alelo. 
     * ci no pertenece a Ri+1/1
     * V[i] > 0. 
     * Reqss[i] > 0.

     Se insertan tantos clientes como la cantidad de los mismos en la segunda mitad 
     de Ri+1

   - Si se cumplen las condiciones y se ingresa al cliente a la ruta Hi+1, se 
     actualiza V de la siguiente manera: 
     * V[i]--;
     * Reqs[i]--;

Pseudocódigo. 
   Para cada dia i
      Para cada camion j
         R1 <- Padre1[i][j]
         R2 <- Padre2[i][j]

         H1 <- R1/1 // Ojo, se controla restricciones como se explico más arriba
         H2 <- R2/2

         Para H1/2, recorrer R1 desde el comienzo e insertar 

------ COMPLETAR PSEUDOCÓDIGO ---------------

   En nuestro ejemplo: 

R1 ->  [10,3,1,4,   |  5,2,8  ]   corte1=4,c1Size-corte1=3
R2 ->  [4,23,3,1,2  |  5,6,9,7]   corte2=5,c2Size-corte2=4
---------------------------------------------
H1 ->  [10,3,1,4    | 2,5,6,9]   corte1=4,c1Size-corte2=4    7
       --<R1/1>--
H2 ->  [4,23,3,1,2  |5,8 ]   corte2=5,c2Size-corte1=3
       --<R2/1>--        

Observación: Nótese que al correr el algoritmo fue excluido el 7. Esto va a 
suceder siempre que en la primera que un individuo de la primera mitad de uno de 
los padres, aparezca en la segunda mitad del otro. Entonces, al completar el nuevo
hijo, se incluirá desde la primera mitad del padre que lo tiene en la primera mitad, 
y no llegaremos a recorrerlo por completo. Entonces, usando la información local, 
realizamos al final un ajuste: 

Ajuste de visitas locales.
Para cada cliente con V[i]>0 hacer
     l <- V[i]
     Si l==2
         metener i en las dos rutas.
     sino si l==1
         -- Ver donde sobra espacio, según la idea inicial de espacio (para controlar
         -- equilibrio de rutas
         espacio1 = (corte1 +c1Size-corte2) - H1.size();
         espacio2 = (corte2 +c2Size-corte1) - H2.size();

         si espacio1>0 y cumple con restricción global en H1
            entonces meter l en H1
         sino si espacio2> 0 y cumple con restricción global en H2
            entonces meter l en H2. 
         sino
            meter l donde aún se pueda según restricción global
     fin

                    V -> [ 0, 1 , 0 , 1 , 2 , 1 , 1 , 0 , 1 , 0...]
                           1  2   3   4   5   6   7   8   9  10...
Paso 1:                  [ 0, 1 , 0 , 0 , 2 , 1 , 1 , 0 , 1 , ...]
Paso 2, 3, 4: Descartado [ 0, 1 , 0 , 0 , 2 , 1 , 1 , 0 , 1 , ...]
Paso 5:                  [ 0, 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , ...]
Paso 6:                  [ 0, 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , ...]
Paso 7:                  [ 0, 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , ...] 
----> Obs. Especial
  La lista de clientes 
  de la ruta recorrida
  que no fueron incluidos
  en la nueva ruta, se 
  deben almacenar porque 
  se incluirán en el otro
  hijo. En este caso, se
  guarda "7"
Pasamos a H2
Paso 8:                  [ 0, 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , ...]
Paso 9:                  [ 0, 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , ...]
--> A partir de aqui 
    colocamos los que 
    faltaron en el 
    recorrido de la 
    ruta anterior. 
Paso 10:                  [ 0, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , ...]

----------------------------------------------------------------------------
HIJOS PRODUCIDOS

H1 ->  [10,3,1,4,2,5,6,9]
H2 ->  [4,23,3,1,2,5,8,7 ]



Al terminar, se repite el mismo proceso con los demás padres.

En cada caso, se cruza el camión i del cromosoma 1 con el camión (i+1) mod k del
otro camión. Esto es para asegurar que los cromosomas no se produzcan todos con 
cargas excesivas a los primeros camiones. 


4. MUTACIÓN

   A diferencia del cruce, la mutación no presenta complicaciones para asegurar 
   validez de los alelos. Se realiza básicamente un Cruce de inversión.

   La primera idea es aplicar el cruce, pero sobre el mismo Cromosoma. Esto no
   es tan bueno. 

   Segunda idea: random del porcentaje de mutación. Según este porcentaje, 
   recorremos el cromosoma y usando el porcentaje cambiamos o no el valor.
   - Primero, reinicializamos vector de visitas requeridas
   - A medida que recorremos, segun aparecen los clientes disminuimos sus 
     visitas requeridas y si se decide cambiar al cliente, se disminuye al que 
     entra y se aumenta al que sale
   - La probabilidad de mutación mencionada en este apartado no es la misma que 
     la probabilidad de mutacion del Cromosoma en sí.

   Idea Final: 

   Se recorren los individuos de la población, y se realiza la mutación o no
   según una probabilidad de mutación que se establece al inicializar la población
   
   Para cada día i
      mitad <- i+1
      mezclar rutas de camion i con el de camion i+mitad
   fin

   Procedimiento de mezcla de rutas (Ruta1, Ruta2)
      Elegir valor k aleatorio
      Elegir k pares aleatorios de indices (i,j)
         donde i es un indice valido en la Ruta1
               j es un indice valido en la Ruta2

      swap(Ruta1[i],Ruta2[j])

De por si, como solo se realizan intercambios, siempre se mantiene la propiedad
de validez si el cromosoma original era válido. 

PENALIZACIONES: Si por algún motivo el cruce produce algún cromosoma inválido, 
                se penaliza la situación aumentandole el costo del cromosoma y 
                por lo tanto disminuyendo el fitness. 
                
                Por cada cliente no visitado, se suma al costo de las rutas, el 
                costo de ir desde el deposito hasta dicho cliente y volver. 
    
                Esto representa el costo en la vida real, si nos olvidamos de un
                cliente, esto nos requiere y tenemos que ir y volver hasta el 
                mismo, desde el deposito.

                No existe Pena de muerte

REEMPLAZO:


     * El reemplazo definido sigue un modelo híbrido (semiestacionario) ya que
     * en cada generacio, hay una nueva población, pero se salva al mejor 
     * individuo de la generación anterior y se reemplaza al peor de la nueva 
     * generación.


ALGORITMO SIMPLE
==============================================================================

inicializarPop
evaluacion 
seleccion
reemplazo
cruce
mutacion
evaluar


